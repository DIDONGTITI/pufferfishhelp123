# Post-quantum resistant double ratchet algorithm

Currently SimpleX Chat uses [double-ratchet with header encryption](https://signal.org/docs/specifications/doubleratchet/#double-ratchet-with-header-encryption) to provide end-to-end encryption to messages and files. This document proposes a way to augment this algorithm with post-quantum key encapsulation mechanism (KEM) to make it resistant to quantum computers.

This is purposefully written in an informal style to make it understandable for general audience with some technical, but without mathematical background. It does not compromise on the technical accuracy though.

## Problem

It is a reasonable assumption that "record-now-decrypt-later" attacks are ongoing, so the users want to use cryptographic schemes for end-to-end encryption that are augmented with some post-quantum algorithm that is believed to be resistant to quantum computers.

Double-ratchet algorithm is a state of the art solution for end to end encryption offering a set of qualities that is unmatched by any other algorithm:

- perfect forward secrecy, i.e. compromise of session or long term keys does not lead to the ability to decrypt any of the past messages.
- deniability (also known as repudiation), i.e. the fact that the recipient of the message cannot prove to a third party that the sender actually sent this message [1].
- break-in recovery (also know as post-compromise security or future secrecy), i.e. the ability of the end to end encryption security to recover from the compromise of the long term keys. This is achieved by generating a new random key pair whenever a new DH key is received (DH ratchet step).

It is desirable to preserve all these qualities when augmenting the algorithm with a post-quantum algorithm, having these qualities resistant (or "believed to be" [2] resistant) to both conventional and quantum computers.

## Critique of the proposed solutions

### PQXDH

[The solution](https://signal.org/docs/specifications/pqxdh/) recently [introduced by Signal](https://signal.org/blog/pqxdh/) augments the initial key agreement ([X3DH](https://signal.org/docs/specifications/x3dh/)) that is made prior to double ratchet algorithm. This is believed to provide protection from "record-now-decrypt-later" attack, but if the attacker at any point obtains long term keys from any of the devices, the break-in recovery will not be post-quantum resistant, and the attacker would be able to decrypt all the subsequent messages.

In addition to that, the authentication of parties in the proposed scheme is also not post-quantum resistant, although this is not part of double ratchet algorithm.

### Hybrid Signal protocol for post-quantum encryption

[The solution](https://eprint.iacr.org/2021/875.pdf) [proposed by Tutanota](https://tutanota.com/blog/posts/pqmail-update/) aims to preserve the break-in recovery property of double ratchet, but in doing so it:
- replaces rather than augments DH key agreement with post-quantum KEM mechanism, making it potentially vulnerable to conventional computers.
- adds signature to the DH ratchet step, to compensate for not keeping DH key agreement, but losing the deniability property for some of the messages.

## Proposed solution

Neither of the above compromises are necessary, as it is possible to augment the double ratchet algorithm with post-quantum KEM mechanism, preserving all the properties of the double ratchet algorithm.

This is possible because although double ratchet uses DH, which is non-interactive key exchange, it uses it "interactively", when the new DH key is only generated by a party after the new DH key is received from another party. Parties of double-ratchet encrypted communication can run post-quantum key encapsulation mechanism in parallel with DH key agreement on each DH ratchet step, making break-in recovery property of double ratchet algorithm post-quantum resistant (unlike PQXFH scheme) without losing deniability or resistance to conventional computers (unlike Tutanota scheme).

Specifically, it is proposed to augment [double ratchet with encrypted headers](https://signal.org/docs/specifications/doubleratchet/#double-ratchet-with-header-encryption) with [ML-KEM algorithm](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.203.ipd.pdf) (based on CRYSTALS-Kyber submission) as described below.

The downside of the proposed scheme is substantial size overhead, as the encapsulation key and encapsulated shared secret are added to the header of each message – ML-KEM-768 adds ~2kb to each message, and ML-KEM-1024 – ~3kb.

As SimpleX Chat uses fixed size 16kb blocks for each message, irrespective of actual message size, for most messages it would not cause additional traffic, but for large texts it may require additional messages to be sent.

That might have been the primary reason why this scheme was not adopted by Signal, as it would result in substantial traffic growth as Signal messages are not padded to fixed size.

### Initialization

The double ratchet initialization is defined in pseudocode as follows:

```
// Alice obtained Bob's keys and initializes ratchet first
def RatchetInitAliceHEPQ(state, SK, bob_dh_public_key, shared_hka, shared_nhkb, bob_pq_kem_encapsulation_key):
    state.DHRs = GENERATE_DH()
    state.DHRr = bob_dh_public_key
    // below added for post-quantum ML-KEM / Kyber
    state.PQRs = GENERATE_PQ_KEM()
    state.PQRr = bob_pq_kem_encapsulation_key
    state.PQRss = random // shared secret for ML-KEM / Kyber
    state.PQRenc_ss = PQKEM-ENC(state.PQRr.encaps, state.PQRss) // encapsulated additional shared secret
    // above added for ML-KEM / Kyber
    // below augments DH key agreement with PQ shared secret
    state.RK, state.CKs, state.NHKs = KDF_RK_HE(SK, DH(state.DHRs, state.DHRr) || state.PQRss) 
    state.CKr = None
    state.Ns = 0
    state.Nr = 0
    state.PN = 0
    state.MKSKIPPED = {}
    state.HKs = shared_hka
    state.HKr = None
    state.NHKr = shared_nhkb

// Bob initializes ratchet second, having received Alice's connection request
def RatchetInitBobHEPQ(state, SK, bob_dh_key_pair, shared_hka, shared_nhkb, bob_pq_kem_key_pair):
    state.DHRs = bob_dh_key_pair
    state.DHRr = None
    // below added for ML-KEM / Kyber
    state.PQRs = bob_pq_kem_key_pair
    state.PQRr = None
    // above added for ML-KEM / Kyber
    state.RK = SK 
    state.CKs = None
    state.CKr = None
    state.Ns = 0
    state.Nr = 0
    state.PN = 0
    state.MKSKIPPED = {}
    state.HKs = None
    state.NHKs = shared_nhkb
    state.HKr = None
    state.NHKr = shared_hka
```

`GENERATE_PQ_KEM` generates decapsulation/encapsulation key pair.

`PQKEM-ENC` is key encapsulation algorithm.

Other than commented lines, the above adds parameters `bob_pq_kem_encapsulation_key` and `bob_pq_kem_key_pair` to the ratchet intialization. Otherwise it is identical to the original double ratchet initialization.

### Encrypting messages

```
def RatchetEncryptHEPQ(state, plaintext, AD):
    state.CKs, mk = KDF_CK(state.CKs)
    // encapsulation key from PQRs and encapsulated shared secret is added to header
    header = HEADERPQ(state.DHRs.public, state.PN, state.Ns, state.PQRs.encaps, state.PQRenc_ss)
    enc_header = HENCRYPT(state.HKs, headerpq)
    state.Ns += 1
    return enc_header, ENCRYPT(mk, plaintext, CONCAT(AD, enc_header))
```

Other than adding encapsulation key and encapsulated shared secret into the header, the above is identical to the original double ratchet message encryption step.

As an optimization, to save space, it might be possible to add encapsulation key and encapsulated secret only when they change. The downside of this optimization would be that it will be impossible to decrypt the message when the message that has them is skipped or lost, compromising the ability of double ratchet to manage skipped messages.

### Decrypting messages

```
def RatchetDecryptHEPQ(state, enc_header, ciphertext, AD):
    plaintext = TrySkippedMessageKeysHE(state, enc_header, ciphertext, AD)
    if plaintext != None:
        return plaintext
    header, dh_ratchet = DecryptHeader(state, enc_header)
    if dh_ratchet:
        SkipMessageKeysHE(state, header.pn)
        DHRatchetHEPQ(state, header)
    SkipMessageKeysHE(state, header.n)
    state.CKr, mk = KDF_CK(state.CKr)
    state.Nr += 1
    return DECRYPT(mk, ciphertext, CONCAT(AD, enc_header))

def DHRatchetHEPQ(state, header):
    state.PN = state.Ns
    state.Ns = 0
    state.Nr = 0
    state.HKs = state.NHKs
    state.HKr = state.NHKr
    state.DHRr = header.dh
    state.PQRr = header.encaps
    // decapsulate shared secret from header
    ss = PQKEM-DEC(state.PQRs.decaps, header.encaps_ss)
    state.RK, state.CKr, state.NHKr = KDF_RK_HE(state.RK, DH(state.DHRs, state.DHRr) || ss)
    state.DHRs = GENERATE_DH()
    // below is added for ML-KEM / Kyber
    state.PQRs = GENERATE_PQ_KEM() // generate new PQ key pair
    state.PQRss = random // shared secret for ML-KEM / Kyber
    state.PQRenc_ss = PQKEM-ENC(state.PQRr.encaps, state.PQRss) // encapsulated additional shared secret
    // above is added for ML-KEM / Kyber
    state.RK, state.CKs, state.NHKs = KDF_RK_HE(state.RK, DH(state.DHRs, state.DHRr) || state.PQRss)
```

`PQKEM-DEC` is key decapsulation algorithm.

`DHRatchetHEPQ` augments both DH agreements with decapsulated shared secret from the received header and with the new shared secret, respectively. The new shared secret together with the new encapsulation key are saved in the state and will be added to the header in the next sent message.

Other than augmenting DH key agreements with the shared secrets from ML-KEM, the above is identical to the original double ratchet DH ratchet step.

It is worth noting that while DH agreements work as ping-pong, when the new received DH key is used for both DH agreements (and only the sent DH key is updated for the second DH key agreement), PQ ML-KEM agreements in the proposed scheme work as a "parallel ping-pong", with two balls in play all the time (two ML-KEM agreements run in parallel).

## Summary

If ML-KEM proves secure against quantum computer attacks, then the proposed augmented double ratchet will also be secure against quantum computer attack, including break-in recovery property, while keeping deniability and forward secrecy, as the [same proof](https://eprint.iacr.org/2016/1013.pdf) as for double ratchet algorithm would hold here.

[1] This is often misunderstood to mean that the recipient cannot prove that the sender sent the message at all, which is incorrect, as the recipient has the proof that either themselves or the sender encrypted the message, and as they know that the recipient themselves did not encrypt it, therefore the sender did. So the communication is secure and authenticated for the recipient, without being a proof to a third party.

[2] This is important to remember that no existing post-quantum algorithms are proven to be resistant to quantum or conventional computers, therefore the approach recommended by NIST is to augment rather than replace existing algorithms with post-quantum ones.